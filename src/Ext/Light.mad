import type { Rect, Vector2 } from "../Math"
import type { Shader } from "../Shader"
import type { VertexBuffer } from "../VertexBuffer"

import Array from "Array"
import Short from "Short"

import BlendMode from "../BlendMode"
import Circle from "../Circle"
import Math from "../Math"
import PrimitiveType from "../PrimitiveType"
import Rectangle from "../Rectangle"
import RenderStates from "../RenderStates"
import Shader from "../Shader"
import Vertex from "../Vertex"
import VertexBuffer from "../VertexBuffer"
import View from "../View"
import Window from "../Window"



V_SHADER_LIGHT = `
varying vec2 vLightPosition;
varying vec2 vPosition;
uniform vec2 uLightPosition;

void main() {
  vLightPosition = (gl_ModelViewProjectionMatrix * vec4(uLightPosition.xy, 0, 1)).xy;
  gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;
  vPosition = gl_Position.xy;
}
`

F_SHADER_LIGHT = `
#version 120
varying vec2 vLightPosition;
varying vec2 vPosition;

void main() {
  vec4 lightColor = vec4(0.2, 0.2, 0.2, 1.0);
  float distance = length(vLightPosition - vPosition);
  float constant = .2;
  float linear = 3.0;
  float quadratic = 15;
  // float attenuation = 1.0 / (distance * distance);
  float attenuation = 1.0 / (constant + linear * distance + quadratic * (distance * distance));

  vec4 color = vec4(attenuation * lightColor.rgb, 1.0);

  gl_FragColor = color;
}
`

V_SHADER_SHADOW = `
#extension GL_EXT_gpu_shader4 : require
uniform vec2 uLightPosition;

void main() {
  vec2 vLightPosition = (gl_ModelViewProjectionMatrix * vec4(uLightPosition.xy, 0, 1)).xy * 1.0001;
  vec4 position = gl_ModelViewProjectionMatrix * gl_Vertex;
  gl_Position = position;

  if(gl_VertexID % 2 == 0) {
    gl_Position = vec4(position.xy - vLightPosition, position.z, 0.0);
  }
}
`

F_SHADER_SHADOW = `
uniform float uResolution;

void main() {
  float alphaStep = 1.0 / uResolution;
  gl_FragColor = vec4(0.0, 0.0, 0.0, alphaStep);
}
`


alias LightManagerData = { lightShader :: Shader, shadowShader :: Shader }

type LightManager = LightManager(LightManagerData)
export type LightManager

alias LightData = {
  casterBuffers :: Array VertexBuffer,
  position :: Vector2 Float,
}

type Light = Light(LightData)
export type Light


makeLightManager :: {} -> LightManager
export makeLightManager = () => {
  lightShader = Shader.new()
  Shader.loadVertexAndFragmentShaderFromMemory(V_SHADER_LIGHT, F_SHADER_LIGHT, lightShader)

  shadowShader = Shader.new()
  Shader.loadVertexAndFragmentShaderFromMemory(V_SHADER_SHADOW, F_SHADER_SHADOW, shadowShader)

  return LightManager({ lightShader, shadowShader })
}


LIGHT_BLENDING_MODE = BlendMode.makeWithAlpha(
  BlendMode.DstAlpha,
  BlendMode.One,
  BlendMode.Add,
  BlendMode.One,
  BlendMode.Zero,
  BlendMode.Add,
)
SHADOW_BLENDING_MODE = BlendMode.makeWithAlpha(
  BlendMode.Zero,
  BlendMode.One,
  BlendMode.Add,
  BlendMode.Zero,
  BlendMode.Zero,
  BlendMode.Add,
)

_SHADOW_BLENDING_MODE = BlendMode.makeWithAlpha(
  BlendMode.Zero,
  BlendMode.One,
  BlendMode.Add,
  BlendMode.One,
  BlendMode.One,
  BlendMode.ReverseSubtract,
)


setPosition :: Float -> Float -> Light -> Light
export setPosition = (x, y, light) => where(light) {
  Light(data) =>
    do {
      data.position := Math.Vector2(x, y)
      return light
    }
}


drawBuffersWithRenderStates :: Array VertexBuffer -> RenderStates -> Window -> {}
drawBuffersWithRenderStates = (buffers, rs, window) => {
  i = 0
  while(i < Array.length(buffers)) do {
    VertexBuffer.drawWithRenderStates(buffers[i], rs, window)
    i := i + 1
  }
}


draw :: LightManager -> Light -> Window -> {}
export draw = (manager, light, window) => {
  rect = pipe(
    Window.getView,
    View.getSize,
    where {
      Math.Vector2(w, h) =>
        Rectangle.make(w, h)
    },
  )(window)

  shaders = where(manager) {
    LightManager(_shaders) =>
      _shaders
  }

  lightData = where(light) {
    Light(_lightData) =>
      _lightData
  }

  lightRenderStates = RenderStates.default()
  RenderStates.setShader(shaders.lightShader, lightRenderStates)
  RenderStates.setBlendMode(LIGHT_BLENDING_MODE, lightRenderStates)

  shadowRenderStates = RenderStates.default()
  RenderStates.setShader(shaders.shadowShader, shadowRenderStates)
  RenderStates.setBlendMode(SHADOW_BLENDING_MODE, shadowRenderStates)
  _shadowRenderStates = RenderStates.default()
  RenderStates.setShader(shaders.shadowShader, _shadowRenderStates)
  RenderStates.setBlendMode(_SHADOW_BLENDING_MODE, _shadowRenderStates)

  resolution = 36
  radius = 20
  c = Circle.make(radius)
  Circle.setPointCount(resolution, c)

  where(lightData.position) {
    Math.Vector2(x, y) =>
      do {
        i = 0
        Shader.setFloatUniform("uResolution", Short.toFloat(resolution + 1), shaders.shadowShader)
        Shader.setVec2Uniform("uLightPosition", x, y, shaders.shadowShader)
        drawBuffersWithRenderStates(lightData.casterBuffers, _shadowRenderStates, window)

        while(i < resolution) do {
          where(Circle.getPoint(i, c)) {
            Math.Vector2(_x, _y) =>
              do {
                Shader.setFloatUniform(
                  "uResolution",
                  Short.toFloat(resolution + 1),
                  shaders.shadowShader,
                )
                Shader.setVec2Uniform(
                  "uLightPosition",
                  x + _x - radius,
                  y + _y - radius,
                  shaders.shadowShader,
                )
                drawBuffersWithRenderStates(
                  lightData.casterBuffers,
                  _shadowRenderStates,
                  window,
                )
              }
          }
          i := i + 1
        }

        Shader.setVec2Uniform("uLightPosition", x, y, shaders.lightShader)
        Rectangle.drawWithRenderStates(rect, lightRenderStates, window)
      }
  }
}


buildBuffer :: Array Vertex -> VertexBuffer
buildBuffer = (vertices) => {
  buffer = VertexBuffer.makeWithPrimitiveType(PrimitiveType.TriangleStrip)
  VertexBuffer.allocate(Short.fromInteger(Array.length(vertices)), buffer)
  VertexBuffer.update(vertices, buffer)
  return buffer
}


make :: Vector2 Float -> Array Vertex -> Light
export make = (position, vertices) => {
  buffer = buildBuffer(vertices)

  return Light({ position, casterBuffers: Array.fromList([buffer]) })
}

addRectCaster :: Rect Float -> Light -> Light
export addRectCaster = (rect, light) => {
  newVertices = where(rect) {
    Math.Rect(x, y, w, h) =>
      Array.fromList([
        Vertex.fromPosition(x, y),
        Vertex.fromPosition(x, y),
        Vertex.fromPosition(x, y + h),
        Vertex.fromPosition(x, y + h),
        Vertex.fromPosition(x + w, y + h),
        Vertex.fromPosition(x + w, y + h),
        Vertex.fromPosition(x + w, y),
        Vertex.fromPosition(x + w, y),
        Vertex.fromPosition(x, y),
        Vertex.fromPosition(x, y),
      ])
  }

  where(light) {
    Light({ casterBuffers }) =>
      Array.push(buildBuffer(newVertices), casterBuffers)
      // VertexBuffer.update(newVertices, casterBuffers)
  }

  return light
}
